# -*- coding: utf-8 -*-
"""CA_clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uEIDD3O5yHDal2o5dCB7tV9CyHeXfQlW
"""
import numpy as np
import random
from PIL import Image
import time
import os
# import imageio

class Rule:
  def __init__(self,states,death_rule,survival_rule,birth_rule,color_map):
    self.states = states
    self.death_rule = death_rule
    self.survival_rule = survival_rule
    self.birth_rule =birth_rule
    self.color_map=color_map

color_map = {
    0: (0, 0, 0),
    1: (255, 120, 255),
    2: (0, 0, 255),
    3: (255, 255, 0),
    4: (255, 0, 255),
    5: (0, 255, 255),
    6: (128, 0, 0),
    7: (0, 128, 0),
    8: (0, 0, 128)
}

class Grid:
    def __init__(self,rule):
        self.grid = np.zeros((100,100))
        self.rule = rule
    # def update(self):
    #     new_grid = np.zeros(self.grid.shape)

    #     # Create a padded version of the grid
    #     padded_grid = np.pad(self.grid, ((1,1),(1,1)), mode='wrap')

    #     # Iterate over the cells in the original grid
    #     for i in range(1,self.grid.shape[0]-1):
    #         for j in range(1,self.grid.shape[1]-1):
    #             # Get the neighborhood from the padded grid
    #             neighborhood = padded_grid[i:i+3, j:j+3]

    #             # Update the cell based on the neighborhood
    #             new_grid[i-1,j-1] = self.generate(neighborhood,self.rule.states,self.rule.death_rule,self.rule.survival_rule,self.rule.birth_rule)



    #     # for i in range(0,self.grid.shape[0]):
    #     #     for j in range(0,self.grid.shape[1]):
    #     #         neighborhood = self.grid[i-1:i+2,j-1:j+2]
    #     #         new_grid[i,j] = self.generate(neighborhood,self.rule.states,self.rule.death_rule,self.rule.survival_rule,self.rule.birth_rule)
    #     self.grid = new_grid
    def update(self):
        new_grid = np.zeros(self.grid.shape)
        for i in range(self.grid.shape[0]):
            for j in range(self.grid.shape[1]):

                # neighborhood = []
                # if(i<1 or j<1 or i>self.grid.shape[0]-2 or j>self.grid.shape[1]-2):

                    

                # Get the indices of the neighbors, wrapping around at the edges
                i_prev = (i-1) % self.grid.shape[0]
                i_next = (i+1) % self.grid.shape[0]
                j_prev = (j-1) % self.grid.shape[1]
                j_next = (j+1) % self.grid.shape[1]                   


                neighborhood = np.array([self.grid[i_prev][j_prev], self.grid[i_prev][j], self.grid[i_prev][j_next],
                                        self.grid[i][j_prev],   self.grid[i][j],   self.grid[i][j_next],
                                        self.grid[i_next][j_prev], self.grid[i_next][j], self.grid[i_next][j_next]])

                
                neighborhood = neighborhood.reshape(3,3)
                # else:
                #     # Select the neighborhood
                #     neighborhood = self.grid[i-1:i+1,j-1:j+1]

                # Update the cell based on the neighborhood
                new_grid[i,j] = self.generate(neighborhood,self.rule.states,self.rule.death_rule,self.rule.survival_rule,self.rule.birth_rule)

        self.grid = new_grid
    def get_grid(self):
        return(self.grid)
    def clear_grid(self):
      self.grid = np.zeros((100,100))
    def get_display(self):
        out =  np.zeros((self.grid.shape[0], self.grid.shape[1], 3), dtype=np.uint8)
        for i in range(1,self.grid.shape[0]-1):
            for j in range(1,self.grid.shape[1]-1):
              out[i][j] = self.rule.color_map[self.grid[i][j]]
        out = Image.fromarray(out)
        out = out.resize((600,600))
        return(out)
    def populate_grid(self,population):
      for i in range(population):
        randy = random.randint(0,self.grid.shape[0]-1)
        randx = random.randint(0,self.grid.shape[1]-1)
        self.grid[randy][randx] =  self.rule.states[-1]

    def generate(self,neighborhood,states,death_rule,survival_rule, birth_rule):
        cell = neighborhood[1][1]
        live_cells = 0
        for i in range(3):
            for j in range(3):
                if i == 1 and j == 1:
                    continue
                if neighborhood[i][j] == states[-1]:
                    live_cells += 1
        #case 1 cell is alive
        if(cell == states[-1]):
            if(live_cells in survival_rule):
                return(cell)
            elif(live_cells in death_rule):
                return(states[0])
            else:
                return(states[states.index(cell)-1])
        #case2 cell is dying
        elif(cell != states[0]):
            return(states[states.index(cell)-1])
        #case 3 cell is dead
        else:
            if(live_cells in birth_rule):
                return(states[-1])
            else:
                return(cell)

# def create_gif(filenames, duration,name):
#     filenames = os.listdir("temp")
#     images = []
#     for filename in filenames:
#         images.append(imageio.v2.imread("temp/"+filename))
#     output_file = 'Gif-%d.gif' % (time.time())
#     imageio.mimsave(output_file, images, duration=duration)
import glob

def make_gif(frame_folder,name):
    frames = [Image.open(image) for image in glob.glob(f"{frame_folder}/*.JPG")]
    frame_one = frames[0]
    frame_one.save(name, format="GIF", append_images=frames,
               save_all=True, duration=300, loop=0)

#states/death/survial/birth
game_of_life = Rule([0,1], [1,4], [2,3],[3],color_map)
new_rule = Rule([0,1], [6], [0,1,7,8],[5],color_map)

test = Grid(new_rule)

test.populate_grid(2000)

for i in range(200):
    test.update()
    if(i<10):
        test.get_display().save("temp/test"+"00"+str(i)+".JPG")
    elif(i<100):
        test.get_display().save("temp/test"+"0"+str(i)+".JPG")
    else:
        test.get_display().save("temp/test"+str(i)+".JPG")
make_gif("temp","test.gif")
