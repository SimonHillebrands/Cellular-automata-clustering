# -*- coding: utf-8 -*-
"""CA_clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uEIDD3O5yHDal2o5dCB7tV9CyHeXfQlW
"""
import numpy as np
import random
from PIL import Image
import time
import cv2
import matplotlib.pyplot as plt
import os

class Rule:
    base_states = [i for i in range(0,9)]
    def __init__(self,states,death_rule,survival_rule,birth_rule,color_map):
        self.states = states
        self.death_rule = death_rule
        self.survival_rule = survival_rule
        self.birth_rule =birth_rule
        self.color_map=color_map

    def gen_name(self):
        #name = ''.join([str(i) for i in self.death_rule]) + '-' + ''.join([str(i) for i in self.survival_rule]) + '-' + ''.join([str(i) for i in self.birth_rule])
        name = ''.join(map(str, self.death_rule)) + '-' + ''.join(map(str, self.survival_rule)) + '-' + ''.join(map(str, self.birth_rule))
        print("name: ",name)
        return name
    def randomize(self):
        self.death_rule =[i for i in range(0,9) if random.randint(0,10) == 0]
        self.survival_rule =[i for i in range(0,9) if random.randint(0,10) == 0]
        self.birth_rule =[i for i in range(0,9) if random.randint(0,10) == 0]

        if(len(self.death_rule) == 0):
            self.death_rule = [random.randint(0,8)]
        if(len(self.survival_rule) == 0):
            self.survival_rule = [random.randint(0,8)]
        if(len(self.birth_rule) == 0):
            self.birth_rule = [random.randint(0,8)]



color_map = {
    0: (0, 0, 0),
    1: (255, 120, 255),
    2: (0, 0, 255),
    3: (255, 255, 0),
    4: (255, 0, 255),
    5: (0, 255, 255),
    6: (128, 0, 0),
    7: (0, 128, 0),
    8: (0, 0, 128)
}

class Grid:
    def __init__(self,rule):
        self.grid = np.zeros((50,50))
        self.rule = rule
    def update(self):
        new_grid = np.zeros(self.grid.shape)
        for i in range(self.grid.shape[0]):
            for j in range(self.grid.shape[1]):

                # neighborhood = []
                # if(i<1 or j<1 or i>self.grid.shape[0]-2 or j>self.grid.shape[1]-2):

                    

                # Get the indices of the neighbors, wrapping around at the edges
                i_prev = (i-1) % self.grid.shape[0]
                i_next = (i+1) % self.grid.shape[0]
                j_prev = (j-1) % self.grid.shape[1]
                j_next = (j+1) % self.grid.shape[1]                   


                neighborhood = np.array([self.grid[i_prev][j_prev], self.grid[i_prev][j], self.grid[i_prev][j_next],
                                        self.grid[i][j_prev],   self.grid[i][j],   self.grid[i][j_next],
                                        self.grid[i_next][j_prev], self.grid[i_next][j], self.grid[i_next][j_next]])

                
                neighborhood = neighborhood.reshape(3,3)
                # else:
                #     # Select the neighborhood
                #     neighborhood = self.grid[i-1:i+1,j-1:j+1]

                # Update the cell based on the neighborhood
                new_grid[i,j] = self.generate(neighborhood,self.rule.states,self.rule.death_rule,self.rule.survival_rule,self.rule.birth_rule)

        self.grid = new_grid
    def get_grid(self):
        return(self.grid)
    def clear_grid(self):
      self.grid = np.zeros((50,50))
    def get_display(self):
        out =  np.zeros((self.grid.shape[0], self.grid.shape[1], 3), dtype=np.uint8)
        for i in range(1,self.grid.shape[0]-1):
            for j in range(1,self.grid.shape[1]-1):
              out[i][j] = self.rule.color_map[self.grid[i][j]]
        out = Image.fromarray(out)
        # out = out.resize((300,300))
        return(out)
    def populate(self,population):
      for i in range(population):
        randy = random.randint(0,self.grid.shape[0]-1)
        randx = random.randint(0,self.grid.shape[1]-1)
        self.grid[randy][randx] =  self.rule.states[-1]

    def generate(self,neighborhood,states,death_rule,survival_rule, birth_rule):
        cell = neighborhood[1][1]
        live_cells = 0
        for i in range(3):
            for j in range(3):
                if i == 1 and j == 1:
                    continue
                if neighborhood[i][j] == states[-1]:
                    live_cells += 1
        #case 1 cell is alive
        if(cell == states[-1]):
            if(live_cells in survival_rule):
                return(cell)
            elif(live_cells in death_rule):
                return(states[0])
            else:
                return(states[states.index(cell)-1])
        #case2 cell is dying
        elif(cell != states[0]):
            return(states[states.index(cell)-1])
        #case 3 cell is dead
        else:
            if(live_cells in birth_rule):
                return(states[-1])
            else:
                return(cell)
            
class Manager:
    def __init__(self,grid):
        self.grid = grid
        self.grid.populate(500)
    
    def regen(self):
        self.grid.clear_grid()
        self.grid.populate(500)
        self.grid.rule.randomize()
    def cluster(self,image):
        # Load the image
        img = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2GRAY)


        # Threshold the image to binarize it
        _, thresh = cv2.threshold(img, 128, 255, cv2.THRESH_BINARY)

        # Perform connected component analysis to obtain the clusters
        num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(thresh, connectivity=8)

        # Sort the clusters by size (largest to smallest)
        sizes = stats[:, -1]
        sorted_idxs = np.argsort(sizes)[::-1]
        sorted_labels = np.zeros_like(labels)
        for i, idx in enumerate(sorted_idxs):
            sorted_labels[labels == idx] = i + 1

        # Apply a color map to the labeled image
        num_labels = np.max(sorted_labels) + 1
        colors = plt.cm.get_cmap('rainbow', num_labels)
        colored_labels = colors(sorted_labels)[:, :, :3] * 255
        colored_labels = colored_labels.astype(np.uint8)

        colored_labels = cv2.resize(colored_labels, (0, 0), fx = 3, fy = 3)

        #print(set(labels.flatten()))

        return [centroids,len(set(labels.flatten()))-1]
    def calculate_fitness(self,generations):
        avg_displacement = []
        avg_clusters = []
        prev_centroids, prev_clusters = self.cluster(self.grid.get_display())
        for i in range(generations):
            self.grid.update()
            centroids, num_clusters = self.cluster(self.grid.get_display())
            displacement = [np.linalg.norm(centroids[j] - prev_centroids[j]) for j in range(min(len(prev_centroids),len(centroids)))]
            avg_displacement.append(np.mean(displacement))      

            avg_clusters.append(num_clusters)

            prev_centroids = centroids
            prev_clusters = num_clusters

            self.save_image(str(i))
        #print(centroids)
        #print(num_clusters)
        displacement_std = np.std(avg_displacement)
        displacement_mean = np.mean(avg_displacement)
        num_clusters_std = np.std(avg_clusters)


        return [displacement_mean,displacement_std,num_clusters_std]
    def save_image(self,name):
        path = self.grid.rule.gen_name()
        isExist = os.path.exists(path)
        if not isExist:

            # Create a new directory because it does not exist
            os.makedirs(path)
        self.grid.get_display().save(path +"/" + name + ".png")

game_of_life = Rule([0,1], [1,4], [2,3],[3],color_map)

test = Grid(game_of_life)

manager = Manager(test)

for i in range(50):
    print(manager.calculate_fitness(100))
    manager.regen()
    print(manager.grid.rule.gen_name())

